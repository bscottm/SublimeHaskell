%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Haskell (improved)
file_extensions:
  - hs
  - hsc
scope: source.haskell

## Useful regex productions for "simple" patterns (like numbers), generally useful patterns that repeat:
variables:
  # Numeric literal patterns taken directly from the "Underscores in Numeric Literals" proposal.
  digit: '\d'
  hexit: '{{digit}}A-Fa-f'
  octit: '0-7'
  binit: '01'
  decimal: '[{{digit}}][{{digit}}_]*'
  hexadecimal: '[{{hexit}}][{{hexit}}_]*'
  octal: '[{{octit}}][{{octit}}_]*'
  binary: '[{{binit}}][{{binit}}_]*'
  exponent: '_?[eE][+-]?{{decimal}}'
  binexponent: '_?[pP][+-]?{{decimal}}'
  # Reserved identifiers: This helps to terminate some of the rule recursion
  reserved_id: |-
    (?x)
    (c(ase|lass)
    |d(ata|e(fault|riving)|o)
    |else
    |foreign
    |i(f|mport|n(fix[lr]?|stance)?)
    |let
    |module
    |newtype
    |of
    |t(hen|ype)
    |where
    |_)
  # Stuff we use very, very regularly...
  type_id: '[A-Z][\w'']*'
  var_id: '(?!\b{{reserved_id}}\b)[a-z_][\w'']*'
  qualified_var: '(({{type_id}}\.)*)({{var_id}})'
  qualified_type: '(({{type_id}}\.)*)({{type_id}})'
  # Symbols (for operator patterns). Note: "\p{S}" is Unicode symbols ("\p{Symbol}") and "\p{P}" is Unicode
  # punctuation ("\p{Punctuation}").
  #
  # specialSymbol is actually very clever (and bscottm did not come up with it, likely it was mvoidex).
  specialSymbol: '[^[^\p{S}\p{P}]_"''\(\),;\[\]`\{\}]'
  ascSymbol: '[\!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\-\~]'
  symbol: '({{ascSymbol}}|{{specialSymbol}})'
  symfuncdef: '(?<=[\w\s])=(?=[\w\s])'
  symguard: '(?<=\s)\|(?=[\w\s])'
  symsignature: '(?<=[\w\s])(::|\u2237)(?=[\w\s])'
  symlambda: '(?<=[\w\s])\\(?=[\w\s])'
  symdef_or_signature: '(?<=[\w\s])[=|::|\u2237](?=[\w\s])'
  # Expanded list of keywords, which includes GHC extensions
  common_keywords: |-
    (?x)
    \b
    ({{reserved_id}}
    |mdo
    |rec
    |proc
    )
    \b
  ## Well known "deriving" types
  well_known_types: |-
    (?x)
    \b
    (Applicative
    |Bounded
    |E(num|q)
    |F(oldable|ractional|unctor)
    |Monoid
    |Num
    |Ord
    |Re(ad|al(Frac)?)
    |Show)
    \b

contexts:
  main:
    - match: ^(module)\b
      captures:
        1: keyword.other.haskell keyword.module.haskell
      push:
        - meta_scope: meta.declaration.module.haskell
        - match: \b(where)\b|(^(?!\s))
          captures:
            1: keyword.module.haskell
          pop: true
        - include: module_name
        - include: module_exports
        - include: comments
        - match: "[a-z]+"
          scope: invalid
    - match: ^(import)\b
      captures:
        1: keyword.other.haskell keyword.import.haskell
      push:
        - meta_scope: meta.import.haskell
        - match: (^(?!\s))
          pop: true
        - match: \b(qualified|as|hiding)\b
          scope: keyword.other.haskell keyword.import.haskell
        - include: module_name
        - include: module_exports
        - include: comments
    ## GHC-specific: C preprocessor-style directives.
    - match: ^\s*(#)\s*\w+
      captures:
        1: punctuation.definition.preprocessor.c punctuation.pragma.preprocessor.haskell
      push:
        - meta_scope: meta.preprocessor.c pragma.preprocessor.haskell
        - match: $
          pop: true
    - include: comments
    - match: '^(foreign)\s+(import|export)((\s+\w+))(\s+\"(\\.|[^\"])*\")?\s*'
      captures:
        1: keyword.declaration.foreign.haskell
        2: keyword.declaration.foreign.haskell
        3: keyword.declaration.foreign.haskell
        5: string.quoted.double.haskell
      push:
        - meta_scope: meta.function.foreign-declaration.haskell
        - match: ^(?!\s)
          pop: true
        - include: foreign_function_signature
    # Top-level declarations
    - match: '({{var_id}})(?!\s*((?!{{symdef_or_signature}}){{symbol}})+\s*{{var_id}})'
      scope: entity.name.function.haskell
      set: fun_binding_or_signature
    - match: '(\(({{symbol}})+\))'
      scope: keyword.operator.haskell
      set: fun_binding_or_signature
    - match: '(`){{qualified_var}}(`)'
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.entity.haskell
        3: punctuation.definition.entity.haskell
    # - include: type_declarations
    # - include: function_declarations
    # - include: expression

  block_comment:
    # This has to be a separate ruleset because it can recurse (block comments within block comments)
    - match: '\{-#\s+'
      # GHC pragma
      scope: punctuation.pragma.haskell comment.pragma.haskell
      push:
        - meta_scope: pragma.haskell
        - match: '#-\}'
          scope: punctuation.pragma.haskell comment.pragma.haskell
          pop: true
        # GHC pragmas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
        - match: |-
            (?x)
            \b
            (CONLIKE
            |DEPRECATED
            |IN(CLUDE|LINE|COHERENT|LINABLE)
            |L(ANGUAGE|INE)
            |MINIMAL
            |NO(INLINE|UNPACK)
            |O(PTIONS_GHC|VERLAP(PING|PABLE|S))
            |RULES
            |S(OURCE|PECIALI[SZ]E)
            |UNPACK
            |WARNING
            )
            \b
          scope: keyword.preprocessor.haskell
        - match: '\b([A-Z][a-z]*)+\b'
          scope: keyword.other.preprocessor.haskell pragma.support.language.haskell
        - match: '(-\w+)'
          scope: keyword.other.preprocessor.haskell pragma.support.flag.haskell

    - match: '\{-\|'
      # Haddock documentation
      scope: comment.block.documentation.haskell
      push:
        - meta_scope: comment.block.documentation.haskell
        - match: '-\}'
          captures:
            0: comment.block.documentation.haskell
          pop: true

    - match: '\{-'
      # Ordinary block comment.
      scope: punctuation.comment.haskell
      push:
        - meta_scope: comment.block.haskell
        - match: '-\}'
          scope: comment.block.haskell
          pop: true
        - include: block_comment

  comments:
    - include: block_comment

    # Haddock one-liners. Note that there __has__ to be a space between the double-dash because Haskell will
    # parse the token as an operator symbol.
    - match: '-- [\|\*\^].*$'
      scope: comment.line.documentation.haskell

    # Regular double-dash comment
    - match: '(--(?!{{symbol}}+)).*$'
      scope: comment.line.double-dash comment.line.haskell
      captures:
        1: punctuation.comment.haskell

  class_declaration:
    - match: '^(\s*)(class)(\s+({{type_id}}))?'
      captures:
        2: keyword.declaration.class.haskell
        3: entity.name.type.haskell
      push:
        - meta_scope: meta.declaration.class.haskell
        - match: \b(where)\b|(^(?!\1\s))
          captures:
            1: keyword.declaration.class.haskell
          pop: true
        - match: '(=>|\u21D2)\\s+({{type_id}})'
          scope: meta.declaration.class.name
          captures:
            1: keyword.operator.haskell
            2: entity.name.type.haskell
        - include: type

  common_keywords:
    - match: '{{common_keywords}}'
      scope: keyword.other.haskell

  constructor_signature:
    - match: '^\s+({{type_id}}|\(\W+\))\s*((::)|âˆ·)'
      captures:
        1: entity.name.function.haskell entity.name.constructor.haskell
        2: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.declaration.function.haskell
        - match: ^(?!\1\s)
          pop: true
        - include: type

  ctor_names:
    - match: '\b{{type_id}}\b'
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: \(\)
      scope: constant.other.haskell entity.name.constructor.haskell

  data_declaration:
    - match: '^(\s*)(data|newtype)\s+({{type_id}})?'
      captures:
        2: keyword.declaration.data.haskell
        3: constant.other.haskell entity.name.class.haskell
      push:
        - meta_scope: meta.declaration.data.haskell
        - match: ^(?!\1\s)
          pop: true
        - match: where
          scope: keyword.declaration.data.haskell
        - include: data_ctor_term
        - include: deriving
        - include: constructor_signature
        - include: record_declaration
        - include: comments
        - include: type

  data_ctor_term:
    # Match constructor terms in a data declaration, which can be of several different styles.
    - match: '([=\|])(\s*({{type_id}}))?'
      captures:
        1: keyword.operator.haskell
        2: entity.name.constructor.haskell
      push:
        - include: type
        - include: comments
        - match: '^\s*({{type_id}})'
          captures:
            1: entity.name.constructor.haskell
        - match: '([=\|])\s*$'
          captures:
            1: keyword.operator.haskell
        - match: '(?=([=\|]|{{reserved_id}}|{{qualified_var}}))'
          pop: true

  deriving:
    - match: \b(deriving)
      scope: keyword.other.haskell keyword.declaration.data.deriving.haskell
      push:
        - meta_scope: meta.data.declaration.deriving.haskell
        - match: '{{qualified_type}}'
          scope: storage.type.haskell support.type.haskell
        - match: \(
          scope: keyword.operator.haskell
          push:
            - match: ','
              scope: keyword.operator.haskell
            - include: type
            - include: comments
            - match: \)
              scope: keyword.operator.haskell
              pop: true
        - include: type
        - match: '(?=\b({{reserved_id}}|{{qualified_var}})\b)'
          pop: true


  field_signature:
    - match: (?=.*?((::)|\u2237))
      push:
        - meta_scope: meta.declaration.field.haskell
        - match: '(?=[,}])'
          pop: true
        - match: \b(\w+)\b\s*((::)|\u2237)
          captures:
            1: storage.type.haskell support.type.haskell
            2: keyword.other.double-colon.haskell
          push:
            - meta_scope: meta.declaration.field.signature.haskell
            - match: "(?=[;}])"
              pop: true
            - include: type
        - match: '(\b{{var_id}}\b|\(\W+\))'
          scope: entity.name.function.haskell
        - include: main

  fixity_declaration:
    - match: '\binfix[lr]?\b'
      scope: keyword.declaration.fixity.haskell

  foreign_function_signature:
    - match: '(\s*)({{var_id}}|\(\W+\))\s*((::)|âˆ·)'
      captures:
        2: entity.name.function.haskell
        3: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.declaration.function.haskell
        - match: ^(?!\s)
          pop: true
        - include: type

  # function_declarations:
  #   - include: function_signature
  #   # - include: function_definition
  #   - include: infix_function_definition
  #   - include: fixity_declaration

  fun_binding_or_signature:
    # Left had side of a function binding or signature. Highlights the function and its arguments (for a binding) or
    # just the function name (for a signature). When the '=' or '::' is encountered, this rule terminates. The right
    # hand side is handled separately.
    #
    # The syntax for a function binding is:
    #
    # funlhs  â†’ var apat { apat }
    #         | pat varop pat
    #         | ( funlhs ) apat { apat }
    #
    # rhs     â†’ = exp [where decls]
    #         | gdrhs [where decls]
    #
    # gdrhs   â†’ guards = exp [gdrhs]
    #
    # guards  â†’ | guard1, â€¦, guardn     (n â‰¥ 1)
    #
    # guard   â†’ pat <- infixexp     (pattern guard)
    #         | let decls     (local declaration)
    #         | infixexp      (boolean guard)
    #
    # fpat  â†’ qvar = pat
    - meta_scope: meta.function.bind_or_sig.haskell
    - match: '{{symfuncdef}}'
      scope: keyword.operator.haskell
      set: expression
    - match: '{{symguard}}'
      scope: keyword.operator.haskell
    - match: '{{symsignature}}'
      scope: keyword.other.double-colon.haskell
      set: type
    - include: apat_toplevel
    - include: comments

  expression:
    # exp       -> infixexp :: [context =>] type     (expression type signature)
    #           |  infixexp
    #
    # infixexp  -> lexp qop infixexp     (infix operator application)
    #           |  - infixexp      (prefix negation)
    #           | lexp
    #
    # lexp      -> \ apat1 â€¦ apatn -> exp      (lambda abstraction, n â‰¥ 1)
    #            | let decls in exp      (let expression)
    #            | if exp [;] then exp [;] else exp      (conditional)
    #            | case exp of { alts }      (case expression)
    #            | do { stmts }      (do expression)
    #            | fexp
    #
    # fexp       -> [fexp] aexp     (function application)
    #
    # aexp  â†’ qvar      (variable)
    # | gcon      (general constructor)
    # | literal
    # | ( exp )     (parenthesized expression)
    # | ( exp1 , â€¦ , expk )     (tuple, k â‰¥ 2)
    # | [ exp1 , â€¦ , expk ]     (list, k â‰¥ 1)
    # | [ exp1 [, exp2] .. [exp3] ]     (arithmetic sequence)
    # | [ exp | qual1 , â€¦ , qualn ]     (list comprehension, n â‰¥ 1)
    # | ( infixexp qop )      (left section)
    # | ( qopâŸ¨-âŸ© infixexp )     (right section)
    # | qcon { fbind1 , â€¦ , fbindn }      (labeled construction, n â‰¥ 0)
    # | aexpâŸ¨qconâŸ© { fbind1 , â€¦ , fbindn }      (labeled update, n  â‰¥  1)

    - meta_scope: meta.haskell.expression
    # Recursion termination conditions:
    - match: '(?=\bin\b|{{symfuncdef}}|^\s*$)'
      pop: true
    - include: prelude_names
    - include: literals
    - match: \bundefined\b
      scope: support.function.prelude.haskell invalid.haskell
      pop: true
    - match: '\b(error)\s*'
      captures:
        1: support.function.prelude.haskell invalid.haskell
      set: expression_string_literal
    - match: '({{type_id}}\.)*(({{type_id}})|({{var_id}}))'
      # Qualified type or variable/function name
      captures:
        1: storage.module.haskell entity.name.module.haskell
        3: storage.module.haskell entity.name.module.haskell
        4: variable.generic
    - match: '{{symbol}}+'
      scope: keyword.operator.haskell
    - match: '(\[|\])'
      # Empty list brackets
      scope: keyword.operator.haskell punctuation.list.haskell
    - match: \(\)
      # Unit.
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: '\[\]'
      # Empty list
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: ','
      scope: punctuation.separator.comma.haskell
    - match: '(\{)(?!-)'
      captures:
        1: keyword.operator.haskell punctuation.record.haskell
      push:
        - meta_scope: record.expression.haskell
        - match: '(?<!-)(\})'
          captures:
            1: keyword.operator.haskell punctuation.record.haskell
          pop: true
        - match: '{{var_id}}\s*(=)'
          captures:
            1: keyword.operator.haskell
        - include: expression
    - match: '\('
      scope: keyword.operator.haskell
      push:
          - meta_scope: meta.expression.parentheses.haskell
          - match: '\)'
            scope: keyword.operator.haskell
            pop: true
          - include: expression
          - include: comments
    - match: '{{symsignature}}'
      scope: keyword.other.double-colon.haskell
    # Optional type qualifier
      set: type
    - match: '{{symlambda}}'
      scope: keyword.operator.haskell
    - match: '(`){{qualified_var}}(`)'
      # In case this regex seems unusual for an infix operator, note that Haskell allows any ordinary function
      # application (elem 4 [1..10]) to be rewritten as an infix expression (4 `elem` [1..10])."
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.entity.haskell
        3: punctuation.definition.entity.haskell
    - match: '\blet\b'
      scope: keyword.other.haskell
      push: let_bindings
    - match: '\bwhere\b'
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.function.where-clause
    - include: quasi_quote
    - include: ctor_names
    - include: comments
    - match: '^\s+(?={{var_id}}.*{{symdef_or_signature}})'
      pop: true

  expression_string_literal:
    - include: string_literal
    - match: ''
      pop: true

  let_bindings:
    - meta_scope: meta.function.let-bindings.haskell
    - match: '\bin\b'
      scope: keyword.other.haskell
      pop: true
    - match: '(({{var_id}})|((\({{symbol}}+\))))'
      captures:
        2: entity.name.function.haskell
        4: keyword.operator.haskell
      push: fun_binding_or_signature

  function_signature:
    - match: '(::|\u2237)'
      scope: keyword.operator.haskell


 # function_signature:
 #    - match: '^(\s*)(?!--)(?:(\(\W\)|[\w'']+)|[\(\[])(?=[\w'',\s\[\]\(\)]*(?:\s*)((?:::)|\u2237))'
 #      captures:
 #        2: entity.name.function.haskell
 #      push:
 #        - meta_scope: meta.declaration.function.haskell
 #        - match: '^(?!\1\s)|(?=})'
 #          pop: true
 #        - match: (?=.*((::)|\u2237))
 #          captures:
 #            1: keyword.name.function.haskell
 #          push:
 #            - meta_scope: meta.declaration.function.names.haskell
 #            - match: ((::)|\u2237)
 #              captures:
 #                1: keyword.other.double-colon.haskell
 #              pop: true
 #            - match: '({{var_id}}|\(\W+\))'
 #              scope: entity.name.function.haskell
 #        - include: type

  apat_toplevel:
    # Top-level function argument patterns. This exists so that we have control over how arguments to top-level functions
    # are colored. Arguments to local functions (let bindings, where clauses) can be colored differently (or not at all).
    #
    # Adapted/taken from the Haskell 2010 report:
    #
    # apat    â†’ var [ @ apat]     (as pattern)
    #         | gcon      (arity gcon  =  0)
    #         | qcon { fpat1 , â€¦ , fpatk }      (labeled pattern, k â‰¥ 0)
    #         | literal
    #         | _     (wildcard)
    #         | ( pat )     (parenthesized pattern)
    #         | ( pat1 , â€¦ , patk )     (tuple pattern, k â‰¥ 2)
    #         | [ pat1 , â€¦ , patk ]     (list pattern, k â‰¥ 1)
    #         | ~ apat      (irrefutable pattern)
    - match: '{{var_id}}'
      scope: variable.parameter.haskell
    - match: '@'
      scope: keyword.operator.haskell
    - match: '{{qualified_type}}'
      captures:
        2: storage.module.haskell entity.name.module.haskell
        3: storage.type.haskell support.type.haskell
    - match: '\b_\b'
      scope: keyword.other.haskell
    - include: literals
    - match: \{
      scope: keyword.operator.haskell
      push:
        - match: \}
          scope: keyword.operator.haskell
          pop: true
        - include: apat_toplevel
    - match: '\('
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.function.pattern.haskell
        - match: '\)'
          scope: keyword.operator.haskell
          pop: true
        - match: ','
          scope: keyword.operator.haskell
        - include: apat_toplevel
    - match: '[~!]'
      scope: keyword.operator.haskell


  function_definition:
    - match: '^\s*({{var_id}}|\({{type_id}}\))\s+(?![^\w\s=''"\(\[])(?=((([\w\.,''"_]+|(?:\w+\@)?\(.*\)|\[.*\])\s+)*))'
      captures:
        1: entity.name.function.haskell
      push:
        - meta_scope: meta.definition.function.haskell
        - match: '\b(=|\||{{reserved_id}})\b'
          scope: keyword.operator.haskell
          pop: true
        - include: expression


  infix_function_definition:
    - match: '^\s*(?=(([\w''\.''"]+|(?:\w+@)?\(.*\)|\[.*\])\s+)+([^"''_,\(\);\[\]`\{\}\:\w\s]+|`{{qualified_var}}`)((\s*[\w''\.''"]+|\s*(?:\w+@)?\(.*\)|\s*\[.*\]))+\s*=)'
      push:
        - meta_scope: meta.definition.function.haskell
        - match: '( [^"''_,\(\);\[\]`\{\}\:\w\s]+|`[a-z][\w'']*`)'
          captures:
            1: entity.name.function.haskell
          pop: true
        - include: expression

  instance_declaration:
    - match: ^(\s*)(instance)\b
      captures:
        2: keyword.declaration.instance.haskell
      push:
        - meta_scope: meta.declaration.instance.haskell
        - match: \b(where)\b|(^(?!\1\s))
          captures:
            1: keyword.declaration.instance.haskell
          pop: true
        - include: type
        - include: comments

  literals:
    - match: |-
        (?x)
        \b
        (           {{decimal}}     ( ( \. {{decimal}} )?     ( {{exponent}}     )? )?
        | 0 ( [xX]_?{{hexadecimal}} ( ( \. {{hexadecimal}} )? ( {{binexponent}}  )? )?
            | [oO]_?{{octal}}
            | [bB]_?{{binary}}
            )
        )
        \b
      scope: constant.numeric.haskell
    - include: string_literal
    - match: |-
        (?x)
        (')
        (?:
          [\ -&(-\[\]-~"]               # Basic Char
          | (\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE
            |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS
            |US|SP|DEL|[abfnrtv\\\"'\&]))   # Escapes
          | (\\o{{octal}})               # Octal Escapes
          | (\\x{{hexadecimal}})           # Hexadecimal Escapes
          | (\^[A-Z@\[\]\\\^_])           # Control Chars
        )
        (')
      scope: string.quoted.single.haskell
      captures:
        2: constant.character.escape.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell

  string_literal:
    - match: '"'
      push:
        - meta_scope: string.quoted.double.haskell
        - match: '"'
          pop: true
        - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
          scope: constant.character.escape.haskell
        - match: '\\o{{octal}}|\\x{{hexadecimal}}|\\{{decimal}}'
          scope: constant.character.escape.octal.haskell
        - match: '\^[A-Z@\[\]\\\^_]'
          scope: constant.character.escape.control.haskell

  module_exports:
    - match: \(
      scope: storage.module.haskell
      push:
        - meta_scope: meta.declaration.exports.haskell
        - match: \)
          scope: storage.module.haskell
          pop: true
        - match: \\\s*$
          push:
            - meta_scope: constant.character.escape.multilinestring.haskell
            - match: \\
              pop: true
        - match: '\b{{var_id}}\b'
          scope: entity.name.function.haskell
        - match: '({{type_id}})\s*(\()'
          captures:
            1: storage.type.haskell storage.data.haskell
            2: keyword.operator.haskell
          push:
            - meta_scope: meta.declaration.export.data.haskell
            - match: \)
              scope: keyword.operator.haskell
              pop: true
            - include: expression
        - match: '\b{{type_id}}\b'
          scope: storage.type.haskell storage.data.haskell
        - match: ','
          scope: punctuation.separator.comma.haskell
        - match: \(.*?\)
          comment: So named because I don't know what to call this.
          scope: meta.other.unknown.haskell
        - include: comments

  module_name:
    - match: '({{type_id}})(\.{{type_id}})*'
      scope: storage.module.haskell

  pattern_function_definition:
    - match: '^\s*(?=\(.*\)|\[.*\]|([A-Z][\w'']*(\s+([\w\s,'']*|\(.*\)|\[.*\]|\{.*\}))*)\s*=)'
      push:
        - meta_scope: meta.definition.function.haskell
        - match: (=)
          scope: keyword.operator.haskell
          pop: true
        - match: '{{var_id}}'
          scope: entity.name.function.haskell
        - include: expression
  quasi_quote:
    - match: '(\[)([a-z]\w*)?(\|)'
      captures:
        1: punctuation.quasi-quoter.haskell keyword.operator.haskell
        2: entity.name.function.haskell
        3: punctuation.quasi-quoter.haskell keyword.operator.haskell
      push:
        - meta_scope: string.quoted.quasi.haskell
        - match: '(\|\])'
          captures:
            1: punctuation.quasi-quoter.haskell keyword.operator.haskell
          pop: true
  record_declaration:
    - match: '(\{)(?!-)'
      captures:
        1: keyword.operator.haskell punctuation.record.haskell
      push:
        - meta_scope: meta.declaration.record.haskell
        - match: '(?<!-)(\})'
          captures:
            1: keyword.operator.haskell punctuation.record.haskell
          pop: true
        - include: field_signature
        - include: comments

  type:
    - match: \s*(->|\u2192)\s*
      scope: keyword.operator.arrow.haskell
    - match: \s*(=>|\u21D2)\s*
      scope: keyword.operator.big-arrow.haskell
    - match: \b({{well_known_types}})\b
      scope: storage.type.haskell support.class.haskell
    - match: '\b{{var_id}}\b'
      scope: variable.generic.haskell
    - match: '\b{{type_id}}\b'
      scope: storage.type.haskell support.type.haskell
    - match: \(\)
      scope: storage.type.haskell
    - match: \(
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.type_signature.brace.haskell
        - match: \)
          scope: keyword.operator.haskell
          pop: true
        - include: type
    - match: \[
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.type_signature.list.haskell
        - match: \]
          scope: keyword.operator.haskell
          pop: true
        - include: type
    - include: prelude_types
    - include: comments

  type_declaration:
    - match: '^(\s*)(type)\s+([A-Z][\w'']*)?'
      captures:
        2: keyword.declaration.data.haskell
        3: entity.name.type.haskell
      push:
        - meta_scope: meta.declaration.type.haskell
        - match: ^(?!\1\s)
          pop: true
        - include: comments
        - match: "="
          scope: keyword.operator.haskell
        - include: type
  type_declarations:
    - include: data_declaration
    - include: type_declaration
    - include: class_declaration
    - include: instance_declaration

  prelude_names:
    # Prelude type and variable names. Not intended to be exhaustive or authoritative
    - match: |-
        (?x)
        \b
        (False
        |EQ
        |GT
        |Just
        |LT
        |Left
        |Nothing
        |Right
        |True
        |a(bs|c(osh?)|ll|n(d|y)|ppendFile|s(TypeOf|inh?)|tan[2h]?)
        |break
        |c(eiling|o(mpare|n(cat(Map)?|st)|sh?)|urry|ycle)
        |d(ecodeFloat|iv(Mod)?|rop(While)?)
        |e(ither|lem|numFrom(Then(To)?|To)?|ven|xp(onent)?)
        |f(ail|ilter|l(ip|o(at(Digits|R(adix|ange))|or))|map|old(l1?|r1?)|rom(Enum|Integ(er|ral)|Rational)|st)
        |g(cd|et(Char|Contents|Line))
        |head
        |i(d|n(it|teract)|oError|s(Denormalized|IEEE|Infinite|N(an|egativeZero))|terate)
        |l(ast|cm|ength|ex|ines|og(Base)?|ookup)
        |m(a(p(M|M_?)?|x(Bound|imum)?|ybe)|in(Bound|imum)?|od)
        |n(egate|ot(Elem)?|ull)
        |o(dd|r|therwise)
        |p(i|r(ed|int|o(duct|perFraction))|ut(Char|Str(Ln)?))
        |quot(Rem)?
        |r((e(a(d(File|IO|L(ist|n)|Paren|s(Prec)?)?)|lToFrac)|cip|m|p(eat|licate)|turn|verse)|ound)
        |s(c(aleFloat|an[lr]1?)|eq(uence_?)?|how(Char|List|Paren|String|s(Prec)?)?|i(gn(ificand|um)|nh?)
          |nd|pan|plitAt|qrt|u(btract|cc|um)
          )
        |t(a(il|ke(While)?|anh?)|o(Enum|Integer|Rational)|runcate)
        |u(n(curry|lines|til|words|zip3?)|serError)
        |w(ords|riteFile)
        |zip(3|With3?)?
        )
        \b
      scope: support.function.prelude.haskell

  prelude_types:
    - match: |-
        (?x)
        (Bool
        |Char
        |Double
        |Either
        |F(ilePath|loat)
        |I(nt(eger)?|O(Error)?)
        |Maybe
        |Ordering
        |ReadS
        |S(howS|tring)
        )
      scope: storage.type.haskell support.type.haskell
