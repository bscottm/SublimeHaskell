%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Haskell (improved)
file_extensions:
  - hs
  - hsc
scope: source.haskell

## Useful regex productions for "simple" patterns (like numbers), generally useful patterns that repeat:
variables:
  # Numeric literal patterns taken directly from the "Underscores in Numeric Literals" proposal.
  digit: '\d'
  hexit: '{{digit}}A-Fa-f'
  octit: '0-7'
  binit: '01'
  decimal: '[{{digit}}][{{digit}}_]*'
  hexadecimal: '[{{hexit}}][{{hexit}}_]*'
  octal: '[{{octit}}][{{octit}}_]*'
  binary: '[{{binit}}][{{binit}}_]*'
  exponent: '_?[eE][+-]?{{decimal}}'
  binexponent: '_?[pP][+-]?{{decimal}}'
  # Reserved identifiers: This helps to terminate some of the rule recursion
  reserved_id: |-
    (?x)
    \b
    (c(ase|lass)
    |d(ata|e(fault|riving)|o)
    |else
    |foreign
    |i(f|mport|n(fix[lr]?|stance)?)
    |let
    |m(do|odule)
    |newtype
    |of
    |proc
    |rec
    |t(hen|ype)
    |where
    )
    \b
  # Stuff we use very, very regularly...
  type_id: '[A-Z][\w'']*'
  free_var: '[a-z_][\w'']*'
  var_id: '(?!{{reserved_id}}){{free_var}}'
  qualified_var: '(({{type_id}}\.)*)({{var_id}})'
  qualified_type: '(({{type_id}}\.)*)({{type_id}})'
  # Symbols (for operator patterns). Note: "\p{S}" is Unicode symbols ("\p{Symbol}") and "\p{P}" is Unicode
  # punctuation ("\p{Punctuation}").
  #
  # specialSymbol is actually very clever (and bscottm did not come up with it, likely it was mvoidex).
  specialSymbol: '[^[^\p{S}\p{P}]_"''\(\),;\[\]`\{\}]'
  ascSymbol: '[\!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\-\~]'
  symbol: '({{ascSymbol}}|{{specialSymbol}})'
  symfuncdef: '(?<=[\w\s])=(?!{{symbol}}+)'
  symguard: '(?<=\s)\|(?=[\w\s])'
  symsignature: '(?<=[\w\s])(::|\u2237)(?=[\w\s])'
  symlambda: '(?<=[\w\s])\\\s*'
  symdef_or_signature: '(?<=[\w\s])[=|::|\u2237](?=[\w\s])'
  ## Well known "deriving" types
  well_known_types: |-
    (?x)
    \b
    (Applicative
    |Bounded
    |E(num|q)
    |F(oldable|ractional|unctor)
    |Monoid
    |Num
    |Ord
    |Re(ad|al(Frac)?)
    |Show)
    \b

contexts:
  main:
    # Top-level declarations
    - match: ^(module)\b
      captures:
        1: keyword.other.haskell keyword.module.haskell
      push:
        - meta_scope: meta.declaration.module.haskell
        - match: \b(where)\b|(^(?!\s))
          captures:
            1: keyword.module.haskell
          pop: true
        - include: module_name
        - include: module_exports
        - include: comments
        - match: "[a-z]+"
          scope: invalid
    - match: ^import\b
      scope: keyword.other.haskell keyword.import.haskell
      push:
        - meta_scope: meta.import.haskell
        - match: (^(?!\s))
          pop: true
        - match: \b(qualified|as|hiding)\b
          scope: keyword.other.haskell keyword.import.haskell
        - include: module_name
        - include: module_exports
        - include: comments
    - match: '^(data|newtype)\s+({{type_id}})?'
      captures:
        1: keyword.declaration.data.haskell
        2: constant.other.haskell entity.name.class.haskell
      push:
        - meta_scope: meta.declaration.data.haskell
        # Context termination condition
        - match: '(?=(^{{reserved_id}}|^\s*$))'
          pop: true
        - match: \b(deriving)\b
          scope: keyword.other.haskell
          set: deriving_expr
        ## Data constructor terms: equal or vertical bar followed by a type id
        - match: '(^|([=\|]))(\s*({{type_id}}))?'
          captures:
            2: keyword.operator.haskell
            4: entity.name.constructor.haskell
        - include: constructor_signature
        - include: record_declaration
        - include: comments
        - include: type
    - match: '\binfix[lr]?\b'
      scope: keyword.declaration.fixity.haskell
      push:
        - match: $
          pop: true
        - match: '{{symbol}}+'
          scope: keyword.operator.haskell
        - match: '(`){{qualified_var}}(`)'
          scope: keyword.operator.function.infix.haskell
          captures:
            1: punctuation.definition.entity.haskell
            3: punctuation.definition.entity.haskell
        - match: ','
          scope: punctuation.separator.sequence.haskell
        - include: literals
    # Binary function, e.g., a ==> b = ...
    - match: '({{var_id}})\s*((?![=|::|\u2237][\w\s]){{symbol}}+)\s*({{var_id}})'
      ## You can only figure out the capture group numbers if you do the variable expansion in
      ## an online regexp tester such as Rubular (www.rubular.com)
      captures:
        1: variable.parameter.haskell
        10: keyword.operator.haskell
        12: variable.parameter.haskell
      set: fun_binding_or_signature
    # A free variable (function name) not followed by an symbol (operator) [example: x ==> y]
    # - match: '({{var_id}})(?!\s*((?![=|::|\u2237][\w\s]){{symbol}}+)\s*{{var_id}})'
    - match: '{{var_id}}'
      scope: entity.name.function.haskell
      set: fun_binding_or_signature
    # A parenthesized operator
    - match: '\({{symbol}}+\)'
      scope: keyword.operator.haskell
      set: fun_binding_or_signature
    - match: '(`){{qualified_var}}(`)'
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.entity.haskell
        3: punctuation.definition.entity.haskell
    ## GHC-specific: C preprocessor-style directives.
    - match: ^\s*(#)\s*\w+
      captures:
        1: punctuation.definition.preprocessor.c punctuation.pragma.preprocessor.haskell
      push:
        - meta_scope: meta.preprocessor.c pragma.preprocessor.haskell
        - match: $
          pop: true
    - include: comments
    # GHC: foreign function interface
    - match: '^(foreign)\s+(import|export)((\s+\w+))(\s+\"(\\.|[^\"])*\")?\s*'
      captures:
        1: keyword.declaration.foreign.haskell
        2: keyword.declaration.foreign.haskell
        3: keyword.declaration.foreign.haskell
        5: string.quoted.double.haskell
      push:
        - meta_scope: meta.function.foreign-declaration.haskell
        - match: ^(?!\s)
          pop: true
        - include: foreign_function_signature
    # - include: type_declarations
    # - include: function_declarations
    # - include: expression

  block_comment:
    # This has to be a separate ruleset because it can recurse (block comments within block comments)
    - match: '\{-#\s+'
      # GHC pragma
      scope: punctuation.pragma.haskell comment.pragma.haskell
      push:
        - meta_scope: pragma.haskell
        - match: '#-\}'
          scope: punctuation.pragma.haskell comment.pragma.haskell
          pop: true
        # GHC pragmas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
        - match: |-
            (?x)
            \b
            (CONLIKE
            |DEPRECATED
            |IN(CLUDE|LINE|COHERENT|LINABLE)
            |L(ANGUAGE|INE)
            |MINIMAL
            |NO(INLINE|UNPACK)
            |O(PTIONS_GHC|VERLAP(PING|PABLE|S))
            |RULES
            |S(OURCE|PECIALI[SZ]E)
            |UNPACK
            |WARNING
            )
            \b
          scope: keyword.preprocessor.haskell
        - match: '\b([A-Z][a-z]*)+\b'
          scope: keyword.other.preprocessor.haskell pragma.support.language.haskell
        - match: '(-\w+)'
          scope: keyword.other.preprocessor.haskell pragma.support.flag.haskell

    - match: '\{-\|'
      # Haddock documentation
      scope: comment.block.documentation.haskell
      push:
        - meta_scope: comment.block.documentation.haskell
        - match: '-\}'
          captures:
            0: comment.block.documentation.haskell
          pop: true

    - match: '\{-'
      # Ordinary block comment.
      scope: punctuation.comment.haskell
      push:
        - meta_scope: comment.block.haskell
        - match: '-\}'
          scope: comment.block.haskell
          pop: true
        - include: block_comment

  comments:
    - include: block_comment

    # Haddock one-liners. Note that there __has__ to be a space between the double-dash because Haskell will
    # parse the token as an operator symbol.
    - match: '-- [\|\*\^].*$'
      scope: comment.line.documentation.haskell

    # Regular double-dash comment
    - match: '(--(?!{{symbol}}+)).*$'
      scope: comment.line.double-dash comment.line.haskell
      captures:
        1: punctuation.comment.haskell

  class_declaration:
    - match: '^(\s*)(class)(\s+({{type_id}}))?'
      captures:
        2: keyword.declaration.class.haskell
        3: entity.name.type.haskell
      push:
        - meta_scope: meta.declaration.class.haskell
        - match: \b(where)\b|(^(?!\1\s))
          captures:
            1: keyword.declaration.class.haskell
          pop: true
        - match: '(=>|\u21D2)\\s+({{type_id}})'
          scope: meta.declaration.class.name
          captures:
            1: keyword.operator.haskell
            2: entity.name.type.haskell
        - include: type

  constructor_signature:
    - match: '^\s+({{type_id}}|\(\W+\))\s*((::)|∷)'
      captures:
        1: entity.name.function.haskell entity.name.constructor.haskell
        2: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.declaration.function.haskell
        - match: ^(?!\1\s)
          pop: true
        - include: type

  ctor_names:
    - match: '\b{{type_id}}\b'
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: \(\)
      scope: constant.other.haskell entity.name.constructor.haskell


  deriving_expr:
    - meta_scope: meta.declaraction.data.deriving
    - match: '{{qualified_type}}'
      scope: storage.type.haskell support.type.haskell
      pop: true
    - match: \(
      scope: keyword.operator.haskell
      push:
        - match: '{{qualified_type}}'
          scope: storage.type.haskell support.type.haskell
        - match: ','
          scope: keyword.operator.haskell
        - include: comments
        - match: \)
          scope: keyword.operator.haskell
          pop: true
    - match: '(?=^({{reserved_id}}|{{var_id}})\b|^\s*$)'
      pop: true
    - include: comments


  field_signature:
    - match: (?=.*?((::)|\u2237))
      push:
        - meta_scope: meta.declaration.field.haskell
        - match: '(?=[,}])'
          pop: true
        - match: \b(\w+)\b\s*((::)|\u2237)
          captures:
            1: storage.type.haskell support.type.haskell
            2: keyword.other.double-colon.haskell
          push:
            - meta_scope: meta.declaration.field.signature.haskell
            - match: "(?=[;}])"
              pop: true
            - include: type
        - match: '(\b{{var_id}}\b|\(\W+\))'
          scope: entity.name.function.haskell
        - include: main


  foreign_function_signature:
    - match: '(\s*)({{var_id}}|\(\W+\))\s*((::)|∷)'
      captures:
        2: entity.name.function.haskell
        3: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.declaration.function.haskell
        - match: ^(?!\s)
          pop: true
        - include: type

  # function_declarations:
  #   - include: function_signature
  #   # - include: function_definition
  #   - include: infix_function_definition
  #   - include: fixity_declaration

  fun_binding_or_signature:
    # Left had side of a function binding or signature. Highlights the function and its arguments (for a binding) or
    # just the function name (for a signature). When the '=' or '::' is encountered, this rule terminates. The right
    # hand side is handled separately.
    #
    # The syntax for a function binding is:
    #
    # funlhs  → var apat { apat }
    #         | pat varop pat
    #         | ( funlhs ) apat { apat }
    #
    # rhs     → = exp [where decls]
    #         | gdrhs [where decls]
    #
    # gdrhs   → guards = exp [gdrhs]
    #
    # guards  → | guard1, …, guardn     (n ≥ 1)
    #
    # guard   → pat <- infixexp     (pattern guard)
    #         | let decls     (local declaration)
    #         | infixexp      (boolean guard)
    #
    # fpat  → qvar = pat
    - meta_scope: meta.function.bind_or_sig.haskell
    # Context escape conditions:
    - match: |-
        (?x)
        (?=(^({{var_id}}
             |(data|(new)?type|class|instance)
             |\s*$
             )
           |\b(in|of)\b
           )
        )
      pop: true
    - match: '{{symfuncdef}}'
      scope: keyword.operator.haskell
      push:
        - include: comments
        ## Hack to handle layout...
        - match: '(^\s+)'
          meta_scope: meta.function.layout.haskell
          push:
            - match: '(?!\1\s*)'
              pop: true
            - include: expression
        - match: '^(?!\s)'
          pop: true
        - include: expression
      set: expression
    - match: '{{symguard}}'
      scope: keyword.other.haskell
      push:
        - match: '{{symfuncdef}}'
          scope: keyword.other.haskell
          set: expression
        - include: expression
    - match: '{{symsignature}}'
      scope: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.type_signature.haskell
        - include: comments
        ## Context escape conditions
        - match: |-
            (?x)
            (?=^({{var_id}}
                   (((\s+{{var_id}})*
                    |.*{{symfuncdef}}.*
                    )$
                   )?
                |\s*$
                |(data|(new)?type|class|instance)
                )
            )
          pop: true
        - include: type
    - include: apat_toplevel
    - include: comments

  expression:
    # exp       -> infixexp :: [context =>] type     (expression type signature)
    #           |  infixexp
    #
    # infixexp  -> lexp qop infixexp     (infix operator application)
    #           |  - infixexp      (prefix negation)
    #           | lexp
    #
    # lexp      -> \ apat1 … apatn -> exp      (lambda abstraction, n ≥ 1)
    #            | let decls in exp      (let expression)
    #            | if exp [;] then exp [;] else exp      (conditional)
    #            | case exp of { alts }      (case expression)
    #            | do { stmts }      (do expression)
    #            | fexp
    #
    # fexp       -> [fexp] aexp     (function application)
    #
    # aexp  → qvar      (variable)
    # | gcon      (general constructor)
    # | literal
    # | ( exp )     (parenthesized expression)
    # | ( exp1 , … , expk )     (tuple, k ≥ 2)
    # | [ exp1 , … , expk ]     (list, k ≥ 1)
    # | [ exp1 [, exp2] .. [exp3] ]     (arithmetic sequence)
    # | [ exp | qual1 , … , qualn ]     (list comprehension, n ≥ 1)
    # | ( infixexp qop )      (left section)
    # | ( qop⟨-⟩ infixexp )     (right section)
    # | qcon { fbind1 , … , fbindn }      (labeled construction, n ≥ 0)
    # | aexp⟨qcon⟩ { fbind1 , … , fbindn }      (labeled update, n  ≥  1)

    - meta_scope: meta.haskell.expression
    # Context escape condition:
    - match: |-
        (?x)
        (?=
         (\b(in|of)\b
         |^(\s*({{var_id}}\s*{{symsignature}}
              |{{symguard}}
              |$)
           |(data|(new)?type|class|instance)\b
           )
         )
        )
      pop: true
    - include: prelude_names
    - include: literals
    - match: \bundefined\b
      scope: support.function.prelude.haskell invalid.haskell
      pop: true
    - match: '\b(error)\s*'
      captures:
        1: support.function.prelude.haskell invalid.haskell
      set: expression_string_literal
    - match: '({{type_id}}\.)*(({{type_id}})|({{var_id}}))'
      # Qualified type or variable/function name
      captures:
        1: storage.module.haskell entity.name.module.haskell
        3: storage.module.haskell entity.name.module.haskell
        4: variable.generic
    - match: '(\[|\])'
      # list brackets
      scope: keyword.operator.haskell punctuation.list.haskell
    - match: \(\)
      # Unit.
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: '\[\]'
      # Empty list
      scope: constant.other.haskell entity.name.constructor.haskell
    - match: ','
      scope: punctuation.separator.comma.haskell
    - match: '(\{)(?!-)'
      captures:
        1: keyword.operator.haskell punctuation.record.haskell
      push:
        - meta_scope: record.expression.haskell
        - match: '(?<!-)(\})'
          captures:
            1: keyword.operator.haskell punctuation.record.haskell
          pop: true
        - match: '{{var_id}}\s*(=)'
          captures:
            1: keyword.operator.haskell
        - include: expression
    - match: '\('
      scope: keyword.operator.haskell
      push:
          - meta_scope: meta.expression.parentheses.haskell
          - match: '\)'
            scope: keyword.operator.haskell
            pop: true
          - include: expression
          - include: comments
    # Optional type qualifier
    - match: '{{symsignature}}'
      scope: keyword.other.double-colon.haskell
      set: type
    - match: '{{symlambda}}'
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.expression.lambda.haskell
        - match: '[\w\s]->[\w\s]'
          scope: keyword.operator.haskell
          pop: true
        - include: apat_toplevel
    - match: '(`){{qualified_var}}(`)'
      # Haskell allows any ordinary function application (elem 4 [1..10]) to be rewritten as an
      # infix expression (4 `elem` [1..10])."
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.entity.haskell
        3: punctuation.definition.entity.haskell
    - match: \blet\b
      scope: keyword.other.haskell
      push: let_decls
    - match: \bwhere\b
      scope: keyword.other.haskell
      push: where_decls
    - match: \bcase\b
      scope: keyword.other.haskell
      push: case_expression
    - match: \bdo\b
      scope: keyword.other.haskell
    - include: quasi_quote
    - include: ctor_names
    - include: comments
    # Do not move this above comments or it will match the comment.
    - match: '{{symbol}}+'
      scope: keyword.operator.haskell


  expression_string_literal:
    - include: string_literal
    - match: ''
      pop: true


  let_decls:
    - meta_scope: meta.function.let-decls.haskell
    - match: '\bin\b'
      scope: keyword.other.haskell
      pop: true
    - match: '(({{var_id}})|((\({{symbol}}+\))))'
      captures:
        2: entity.name.function.haskell
        4: keyword.operator.haskell
      push: fun_binding_or_signature
    - include: comments


  where_decls:
    - meta_scope: meta.function.where-bindings.haskell
    - match: '(?=(^\s*$)|^{{reserved_id}}|^{{var_id}})'
      scope: keyword.other.haskell
      pop: true
    - match: '(({{var_id}})|((\({{symbol}}+\))))'
      captures:
        2: entity.name.function.haskell
        4: keyword.operator.haskell
      push: fun_binding_or_signature
    - include: comments

  case_expression:
    - meta_scope: meta.function.case_expr.haskell
    - match: '(\bof\b|->)'
      scope: keyword.other.haskell
    - include: expression

  function_signature:
    - match: '(::|\u2237)'
      scope: keyword.operator.haskell


 # function_signature:
 #    - match: '^(\s*)(?!--)(?:(\(\W\)|[\w'']+)|[\(\[])(?=[\w'',\s\[\]\(\)]*(?:\s*)((?:::)|\u2237))'
 #      captures:
 #        2: entity.name.function.haskell
 #      push:
 #        - meta_scope: meta.declaration.function.haskell
 #        - match: '^(?!\1\s)|(?=})'
 #          pop: true
 #        - match: (?=.*((::)|\u2237))
 #          captures:
 #            1: keyword.name.function.haskell
 #          push:
 #            - meta_scope: meta.declaration.function.names.haskell
 #            - match: ((::)|\u2237)
 #              captures:
 #                1: keyword.other.double-colon.haskell
 #              pop: true
 #            - match: '({{var_id}}|\(\W+\))'
 #              scope: entity.name.function.haskell
 #        - include: type

  apat_toplevel:
    # Top-level function argument patterns. This exists so that we have control over how arguments to top-level functions
    # are colored. Arguments to local functions (let bindings, where clauses) can be colored differently (or not at all).
    #
    # Adapted/taken from the Haskell 2010 report:
    #
    # apat    → var [ @ apat]     (as pattern)
    #         | gcon      (arity gcon  =  0)
    #         | qcon { fpat1 , … , fpatk }      (labeled pattern, k ≥ 0)
    #         | literal
    #         | _     (wildcard)
    #         | ( pat )     (parenthesized pattern)
    #         | ( pat1 , … , patk )     (tuple pattern, k ≥ 2)
    #         | [ pat1 , … , patk ]     (list pattern, k ≥ 1)
    #         | ~ apat      (irrefutable pattern)
    - match: '{{var_id}}'
      scope: variable.parameter.haskell
    - match: '@'
      scope: keyword.operator.haskell
    - match: '{{qualified_type}}'
      captures:
        2: storage.module.haskell entity.name.module.haskell
        3: storage.type.haskell support.type.haskell
    - match: '\b_\b'
      scope: keyword.other.haskell
    - include: literals
    - match: \{
      scope: keyword.operator.haskell
      push:
        - match: \}
          scope: keyword.operator.haskell
          pop: true
        - include: apat_toplevel
    - match: '\('
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.function.pattern.haskell
        - match: '\)'
          scope: keyword.operator.haskell
          pop: true
        - match: ','
          scope: keyword.operator.haskell
        - include: apat_toplevel
    - match: '[~!]'
      scope: keyword.operator.haskell


  # function_definition:
  #   - match: '^\s*({{var_id}}|\({{type_id}}\))\s+(?![^\w\s=''"\(\[])(?=((([\w\.,''"_]+|(?:\w+\@)?\(.*\)|\[.*\])\s+)*))'
  #     captures:
  #       1: entity.name.function.haskell
  #     push:
  #       - meta_scope: meta.definition.function.haskell
  #       - match: '(=|\||{{reserved_id}})'
  #         scope: keyword.operator.haskell
  #         pop: true
  #       - include: expression


  # infix_function_definition:
  #   - match: '^\s*(?=(([\w''\.''"]+|(?:\w+@)?\(.*\)|\[.*\])\s+)+([^"''_,\(\);\[\]`\{\}\:\w\s]+|`{{qualified_var}}`)((\s*[\w''\.''"]+|\s*(?:\w+@)?\(.*\)|\s*\[.*\]))+\s*=)'
  #     push:
  #       - meta_scope: meta.definition.function.haskell
  #       - match: '( [^"''_,\(\);\[\]`\{\}\:\w\s]+|`[a-z][\w'']*`)'
  #         captures:
  #           1: entity.name.function.haskell
  #         pop: true
  #       - include: expression

  instance_declaration:
    - match: ^(\s*)(instance)\b
      captures:
        2: keyword.declaration.instance.haskell
      push:
        - meta_scope: meta.declaration.instance.haskell
        - match: \b(where)\b|(^(?!\1\s))
          captures:
            1: keyword.declaration.instance.haskell
          pop: true
        - include: type
        - include: comments

  literals:
    - match: |-
        (?x)
        \b
        (           {{decimal}}     ( ( \. {{decimal}} )?     ( {{exponent}}     )? )?
        | 0 ( [xX]_?{{hexadecimal}} ( ( \. {{hexadecimal}} )? ( {{binexponent}}  )? )?
            | [oO]_?{{octal}}
            | [bB]_?{{binary}}
            )
        )
        \b
      scope: constant.numeric.haskell
    - include: string_literal
    - match: |-
        (?x)
        (')
        (?:
          [\ -&(-\[\]-~"]               # Basic Char
          | (\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE
            |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS
            |US|SP|DEL|[abfnrtv\\\"'\&]))   # Escapes
          | (\\o{{octal}})               # Octal Escapes
          | (\\x{{hexadecimal}})           # Hexadecimal Escapes
          | (\^[A-Z@\[\]\\\^_])           # Control Chars
        )
        (')
      scope: string.quoted.single.haskell
      captures:
        2: constant.character.escape.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell

  string_literal:
    - match: '"'
      push:
        - meta_scope: string.quoted.double.haskell
        - match: '"'
          pop: true
        - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
          scope: constant.character.escape.haskell
        - match: '\\o{{octal}}|\\x{{hexadecimal}}|\\{{decimal}}'
          scope: constant.character.escape.octal.haskell
        - match: '\^[A-Z@\[\]\\\^_]'
          scope: constant.character.escape.control.haskell

  module_exports:
    - match: \(
      scope: storage.module.haskell
      push:
        - meta_scope: meta.declaration.exports.haskell
        - match: \)
          scope: storage.module.haskell
          pop: true
        - match: \\\s*$
          push:
            - meta_scope: constant.character.escape.multilinestring.haskell
            - match: \\
              pop: true
        - match: '\b{{var_id}}\b'
          scope: entity.name.function.haskell
        - match: (\(\s*({{symbol}}+)\s*\))
          captures:
            1: keyword.operator.haskell
        - match: '({{type_id}})\s*(\()'
          captures:
            1: storage.type.haskell storage.data.haskell
            2: keyword.operator.haskell
          push:
            - meta_scope: meta.declaration.export.data.haskell
            - match: \)
              scope: keyword.operator.haskell
              pop: true
            - include: expression
        - match: '\b{{type_id}}\b'
          scope: storage.type.haskell storage.data.haskell
        - match: ','
          scope: punctuation.separator.comma.haskell
        - match: \(.*?\)
          comment: So named because I don't know what to call this.
          scope: meta.other.unknown.haskell
        - include: comments

  module_name:
    - match: '({{type_id}})(\.{{type_id}})*'
      scope: storage.module.haskell

  pattern_function_definition:
    - match: '^\s*(?=\(.*\)|\[.*\]|([A-Z][\w'']*(\s+([\w\s,'']*|\(.*\)|\[.*\]|\{.*\}))*)\s*=)'
      push:
        - meta_scope: meta.definition.function.haskell
        - match: (=)
          scope: keyword.operator.haskell
          pop: true
        - match: '{{var_id}}'
          scope: entity.name.function.haskell
        - include: expression
  quasi_quote:
    - match: '(\[)([a-z]\w*)?(\|)'
      captures:
        1: punctuation.quasi-quoter.haskell keyword.operator.haskell
        2: entity.name.function.haskell
        3: punctuation.quasi-quoter.haskell keyword.operator.haskell
      push:
        - meta_scope: string.quoted.quasi.haskell
        - match: '(\|\])'
          captures:
            1: punctuation.quasi-quoter.haskell keyword.operator.haskell
          pop: true
  record_declaration:
    - match: '(\{)(?!-)'
      captures:
        1: keyword.operator.haskell punctuation.record.haskell
      push:
        - meta_scope: meta.declaration.record.haskell
        - match: '(?<!-)(\})'
          captures:
            1: keyword.operator.haskell punctuation.record.haskell
          pop: true
        - include: field_signature
        - include: comments

  type:
    - match: \s*(->|\u2192)\s*
      scope: keyword.operator.arrow.haskell
    - match: \s*(=>|\u21D2)\s*
      scope: keyword.operator.big-arrow.haskell
    - match: \b({{well_known_types}})\b
      scope: storage.type.haskell support.class.haskell
    - match: '\b{{var_id}}\b'
      scope: variable.generic.haskell
    - match: '\b{{type_id}}\b'
      scope: storage.type.haskell support.type.haskell
    - match: \(\)
      scope: storage.type.haskell
    - match: \(
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.type_signature.brace.haskell
        - match: \)
          scope: keyword.operator.haskell
          pop: true
        - include: type
    - match: \[
      scope: keyword.operator.haskell
      push:
        - meta_scope: meta.type_signature.list.haskell
        - match: \]
          scope: keyword.operator.haskell
          pop: true
        - include: type
    - include: prelude_types
    - include: comments

  type_declaration:
    - match: '^(\s*)(type)\s+([A-Z][\w'']*)?'
      captures:
        2: keyword.declaration.data.haskell
        3: entity.name.type.haskell
      push:
        - meta_scope: meta.declaration.type.haskell
        - match: ^(?!\1\s)
          pop: true
        - include: comments
        - match: "="
          scope: keyword.operator.haskell
        - include: type

  type_declarations:
    - include: type_declaration
    - include: class_declaration
    - include: instance_declaration

  prelude_names:
    # Prelude type and variable names. Not intended to be exhaustive or authoritative
    - match: |-
        (?x)
        \b
        (False
        |EQ
        |GT
        |Just
        |LT
        |Left
        |Nothing
        |Right
        |True
        |a(bs|c(osh?)|ll|n(d|y)|ppendFile|s(TypeOf|inh?)|tan[2h]?)
        |break
        |c(eiling|o(mpare|n(cat(Map)?|st)|sh?)|urry|ycle)
        |d(ecodeFloat|iv(Mod)?|rop(While)?)
        |e(ither|lem|numFrom(Then(To)?|To)?|ven|xp(onent)?)
        |f(ail|ilter|l(ip|o(at(Digits|R(adix|ange))|or))|map|old(l1?|r1?)|rom(Enum|Integ(er|ral)|Rational)|st)
        |g(cd|et(Char|Contents|Line))
        |head
        |i(d|n(it|teract)|oError|s(Denormalized|IEEE|Infinite|N(an|egativeZero))|terate)
        |l(ast|cm|ength|ex|ines|og(Base)?|ookup)
        |m(a(p(M|M_?)?|x(Bound|imum)?|ybe)|in(Bound|imum)?|od)
        |n(egate|ot(Elem)?|ull)
        |o(dd|r|therwise)
        |p(i|r(ed|int|o(duct|perFraction))|ut(Char|Str(Ln)?))
        |quot(Rem)?
        |r((e(a(d(File|IO|L(ist|n)|Paren|s(Prec)?)?)|lToFrac)|cip|m|p(eat|licate)|turn|verse)|ound)
        |s(c(aleFloat|an[lr]1?)|eq(uence_?)?|how(Char|List|Paren|String|s(Prec)?)?|i(gn(ificand|um)|nh?)
          |nd|pan|plitAt|qrt|u(btract|cc|um)
          )
        |t(a(il|ke(While)?|anh?)|o(Enum|Integer|Rational)|runcate)
        |u(n(curry|lines|til|words|zip3?)|serError)
        |w(ords|riteFile)
        |zip(3|With3?)?
        )
        \b
      scope: support.function.prelude.haskell

  prelude_types:
    - match: |-
        (?x)
        (Bool
        |Char
        |Double
        |Either
        |F(ilePath|loat)
        |I(nt(eger)?|O(Error)?)
        |Maybe
        |Ordering
        |ReadS
        |S(howS|tring)
        )
      scope: storage.type.haskell support.type.haskell
